---
title: "SM Project"
author: "Amber Day"
date: "4/25/2022"
output: html_document
---
```{r}
rm(list=ls())
```


```{r}
require(aire.zmvm)
require(tidyverse)
require(dplyr)
require(ggplot2)
require(ggseas)
require(ggthemes)
require(reshape2)
require(matrixcalc)
require(mvtnorm)
require(MASS)
```


```{r}
data = get_station_data(criterion = "MAXIMOS", pollutant = "O3", year = 2005:2017)

o3 = get_station_data(criterion = "MAXIMOS", 
pollutant = "O3",
year = 2009:2017)
```


```{r}
# Organizing data

o3_max = o3 %>% group_by(date) %>% summarise(max = ifelse(all(is.na(value)), NA, base::max(value, na.rm = TRUE))) %>% na.omit()

o3_max$anyo = sapply(o3_max$date, function(x) substring(x,1,4))
nueve = o3_max[which(o3_max$anyo == '2009'),]
diez = o3_max[which(o3_max$anyo == '2010'),]
once = o3_max[which(o3_max$anyo == '2011'),]
doce = o3_max[which(o3_max$anyo == '2012'),]
trece = o3_max[which(o3_max$anyo == '2013'),]
catorce = o3_max[which(o3_max$anyo == '2014'),]
quince = o3_max[which(o3_max$anyo == '2015'),]
dieciseis = o3_max[which(o3_max$anyo == '2016'),]
```


```{r}
# Plot 

ggplot(data = nueve) + geom_point(aes(x=1:365,y=max), data=nueve,size=0.03) +
  geom_smooth(aes(x=1:365,y=max), data=diez,size=0.03, alpha=0.1) + geom_smooth(aes(x=1:365,y=max, alpha=0.1), data=once,size=0.03) +
  geom_smooth(aes(x=1:366,y=max, alpha=0.1), data=doce,size=0.03) + geom_smooth(aes(x=1:365,y=max, alpha=0.1), data=trece,size=0.03) +
  geom_smooth(aes(x=1:365,y=max, alpha=0.1), data = catorce,size=0.03) + geom_smooth(aes(x=1:365,y=max, alpha=0.1), data = quince,size=0.03) +
  geom_smooth(aes(x=1:366,y=max, alpha=0.1), data = dieciseis,size=0.03) + theme_bw() + guides(alpha=F)
 # geom_smooth(aes(x=1:366,y=max), data = dieciseis) 

```

```{r}
##Prophet facebook model for fitting time series

require(prophet)
ds <- c(nueve$date, diez$date, once$date, doce$date, trece$date)
y <- c(nueve$max, diez$max, once$max, doce$max,trece$max)
df <- data.frame(ds,y)
m <- prophet(df)
future <- make_future_dataframe(m,100,freq='day')
pred <- predict(m, future)
plot(m,pred) 


ggplot(data = nueve, aes(x=1:365,y=max)) + geom_point(size=0.3) + 
  geom_smooth(method='gam', formula= y~s(x, bs='ps'))
```




-----------------------Emily-------------------------------
```{r}
library(aire.zmvm)
library(tidyverse)

data <- get_station_data(criterion = "MAXIMOS", 
                       pollutant = "O3",
                       year = 2005:2019)


# First let's focus on one station and fit a Gaussian process here
station = "ACO"

aco <- filter(data, station_code==station)

o3_max <- aco %>%
  group_by(date) %>%
  summarise(max = ifelse(all(is.na(value)),
                         NA,
                         base::max(value, na.rm = TRUE)))
o3_max$anyo <- sapply(o3_max$date, function(x) substring(x,1,4))
nueve <- o3_max[which(o3_max$anyo == '2009'),]
diez <- o3_max[which(o3_max$anyo == '2010'),]
once <- o3_max[which(o3_max$anyo == '2011'),]
doce <- o3_max[which(o3_max$anyo == '2012'),]
# remove feb 29
doce = doce[-60,]
trece <- o3_max[which(o3_max$anyo == '2013'),]
catorce <- o3_max[which(o3_max$anyo == '2014'),]
quince <- o3_max[which(o3_max$anyo == '2015'),]
dieciseis <- o3_max[which(o3_max$anyo == '2016'),]
dieciseis = dieciseis[-60,]
```


```{r}
ggplot() + 
  geom_point(aes(x=1:365,y=max), data=diez,size=0.03)

# Now find posterior estimate of f(x)
diez$day = 1:365

diez = drop_na(diez)

# update later to better covariance function
matern_covariance <- function(x, b=1, tau1.sq=1, tau2.sq=1) {
  eucDist = as.matrix(dist(x, diag=T, upper=T))
  kron.delta = diag(nrow=length(x))
  tau1.sq*exp(-0.5*(eucDist/b)^2) + tau2.sq*kron.delta
}
```


```{r}
cov.func = matern_covariance(diez$day)

sig.sq = 2

n = dim(diez)[1]

sigma = solve(1/sig.sq*diag(n)+solve(cov.func))

mu = sigma %*%(1/sig.sq*diez$max)

lower = mu - 1.96*sqrt(diag(sigma))
upper = mu + 1.96*sqrt(diag(sigma))

post.df = data.frame(x=diez$day, y=diez$centered, mean=mu, lower=lower, upper=upper)

ggplot(data=post.df, aes(x=x, y=y)) + 
  geom_point() + 
  geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.5) +
  geom_line(mapping = aes(y=mu))
```

```{r}
# incorporate new kernel

# helper
local_periodic <- function(xi, xj, sigma2=1, p=1, l2=4, c=1.5, a=1){
    sigma2 * exp(-2*sin(pi*abs(xi-xj)/p)^2/l2 ) * exp(-(xi-xj)^2/(2*l2)) * a*(xi-c)*(xj-c)
}

# get the whole matrix
periodic_covariance <- function(x, p=1, l2=4, c=1.5, sigma2=1, a=1) {
  temp = as.matrix(outer(x, x, function(xi, xj) local_periodic(xi, xj, sigma2, p, l2, c, a)))
  temp
}

test = periodic_covariance(diez$day)
```

```{r}
# add column for day of year
nueve$day = 1:365
diez$day = 1:365
once$day = 1:365
doce$day = 1:365
trece$day = 1:365
catorce$day = 1:365
quince$day = 1:365
dieciseis$day = 1:365

# replace NA with zeros
nueve = nueve %>% replace(is.na(.), 0)
diez = diez %>% replace(is.na(.), 0)
once = once %>% replace(is.na(.), 0)
doce = doce %>% replace(is.na(.), 0)
trece = trece %>% replace(is.na(.), 0)
catorce = catorce %>% replace(is.na(.), 0)
quince = quince %>% replace(is.na(.), 0)
dieciseis = dieciseis %>% replace(is.na(.), 0)

# creating a matrix with the max for each of the years we are interested in
max.matrix = cbind(nueve[,2], diez[,2], once[,2], doce[,2], trece[,2], catorce[,2], quince[,2], dieciseis[,2])

max.matrix = as.data.frame(max.matrix)
names(max.matrix) = c("nueve", "diez", "once", "doce", "trece", "catorce", "quince", "dieciseis")
```

```{r}
# Parameters: 
  # - Y is 365 by n_year matrix with pollution levels
  # - mu is 365 by n_year matrix with offset 
  # - s2 is sigma^2
# Returns: 
  # - One sample of conditional posterior draw of vector f(x)
sample.f <- function(Y, mu, s2) {
  # Normal conjugate 
  b = rep(0, 365)
  sigma = matrix(data=0, nrow=365, ncol=365)
  # for each year, calculate b_i and sigma_i then add them to b, sigma
  for (i in 1:dim(Y)[2]) {
    b.i = (Y[,i] - mu[, i]) / s2
    b = b + b.i
    sigma.i = Cinv + diag(1/s2, 365)
    sigma = sigma + sigma.i
  }
  post.var = solve(sigma)
  post.mean = post.var %*% b
  rmvnorm(1, post.mean, post.var)
}

# Parameters: 
  # y: 1x365 vector of values for one single year
  # f: previous draw of f(x) vector
  # s2: sigma^2
# Returns: 
  # 1x365 vector of offsets for single year
sample.mu.i <- function(y, f, s2) {
  b = (y - f) / s2
  sigma = Cinv + diag(1/sigma.sq.mu, 365)
  post.var = solve(sigma)
  post.mean = post.var %*% matrix(b)
  rmvnorm(1, post.mean, post.var)
}

# Parameters:
  # Y is 365 by n_year matrix with pollution levels
  # f - same as above
  # mu: 365 by n_year matrix with offset 
# Returns:
  # inverse gamma draw of s2
sample.s2 <- function(Y, f, mu) {
  a = 0.5 * 2416 - 1 # 2416 is total number of observations
  b = 0
  for (i in 1:dim(Y)[2]) {
    v = Y[,i] - f - mu[,i]
    b =b + 0.5 * t(v) %*% v
  }
  1/rgamma(1, a, b)
}
```

```{r}
# Some unit testing 

sigma.sq = 1
Cinv = diag(1, 365)
sigma.sq.mu = 1
# Test to see if functions have basic functionality
test.out = sample.f(max.matrix, matrix(data=0, nrow=365, ncol=8))
length(test.out) == 365

test2 = sample.mu.i(max.matrix[,1], test.out)
length(test2) == 365

# both return correct length vectors
```

```{r}
# Gibbs sampler

# Fixed parameters
N = sum(
  sum(nueve$max != 0),
  sum(diez$max != 0),
  sum(once$max != 0),
  sum(doce$max != 0),
  sum(trece$max != 0),
  sum(catorce$max != 0),
  sum(quince$max != 0),
  sum(dieciseis$max != 0)
) # 2416 total observations

# Gibbs sampler parameters
n.iter = 1000

# Gibbs sampler storage parameters
mu <- list()
for (year in colnames(max.matrix)) {
  mu[[year]] = matrix(data=NA, nrow=n.iter, ncol=365)
  mu[[year]][1,] = rep(0, 365)
}
mu.iter = matrix(data=0, nrow=365, ncol=length(colnames(max.matrix)))
f = matrix(data=NA, nrow=n.iter, ncol=365)
f[1,] = rep(0, 365)
 
# Start Gibbs sampler
for (iter in 2:n.iter) {
  # Sample f
  f.iter = sample.f(max.matrix, mu.iter)
  f[iter,] = f.iter
  
  # Sample mu_i
  for (id in 1:length(colnames(max.matrix))) {
    mu.i = sample.mu.i(max.matrix[,id], f.iter)
    mu[[colnames(max.matrix)[id]]][iter,] = mu.i
    mu.iter[,id] = mu.i
  }
  print(iter)
}
```


```{r}
f.avg = colMeans(f) 
f.df = data.frame(x=1:365, y=f.avg) 
ggplot(data=f.df, aes(x=x, y=y)) +
  geom_line() 
ggsave("./../Desktop/Sp22/modeling/SDS383c/project/fx_plot.jpeg")
```


```{r}
# Make plots of f(x) for each year 
data_list = list(nueve = nueve, diez = diez, once = once, doce = doce, trece = trece, catorce = catorce, quince = quince, dieciseis = dieciseis)
names_list = list(nueve = 2009, diez = 2010, once = 2011, doce = 2012, trece = 2013, catorce = 2014, quince = 2015, dieciseis = 2016)
for(year in colnames(max.matrix)){
  n = n.iter 
  short = f[1:n,]
  f.avg = colMeans(short) + colMeans(mu[[year]][1:n,])
  f.df = data.frame(x=1:365, y=f.avg)

  # Quantiles for ribbon
  short.quantiles = cbind(rep(0,365),rep(0,365))
  data.q = short + mu[[year]][1:n,]
  for (i in 1:365) {
    short.quantiles[i,] = quantile(data.q[,i],c(0.05,0.95))
  }
  day = 1:365
  # Plot
  p=ggplot(data=f.df, aes(x=x, y=y)) + 
    ggtitle(paste0("Maximum O3 Pollution at Acolman Station In Year ", names_list[[year]]) ) + 
    xlab("Year") + ylab("O3 ppb") +
    geom_line() +
    geom_point(data=data.frame(data_list[[year]]), aes(x=day, y=max), alpha=0.5, size=0.5) + 
    geom_ribbon(aes(ymin=short.quantiles[,1], ymax=short.quantiles[,2]), alpha=0.5) 
  
  ggsave(paste0(year,".png"), width = 40, height = 20, units = "cm")
}

```

```{r}
# Now let's analyze mu for each year

# Average offset for each year (nueve through dieciseis)
nueve_offset = mean(colMeans(mu[["nueve"]])) # -9.816055
diez_offset = mean(colMeans(mu[["diez"]])) # 6.070717
once_offset = mean(colMeans(mu[["once"]])) # 9.923544
doce_offset = mean(colMeans(mu[["doce"]])) # 7.239602
trece_offset = mean(colMeans(mu[["trece"]])) # 12.61491
catorce_offset = mean(colMeans(mu[["catorce"]])) # 4.199782
quince_offset = mean(colMeans(mu[["quince"]])) # -8.430037
dieciseis_offset = mean(colMeans(mu[["dieciseis"]])) # -4.65355

# Make a histogram of mu_i samples for each year
for (year in colnames(max.matrix)) {
  means = colMeans(mu[[year]])
  p = ggplot(data=data.frame(x=means)) + geom_histogram(aes(x=x))
  ggsave(paste("./../Desktop/Sp22/modeling/SDS383c/project/", year, "mu.png", sep=""),
       plot=p)
}

save.image(file="currentenv.RData")
```

```{r}
###########################################################
##########   Gibbs Sampler with Variance  #################
###########################################################
n.iter = 10000

# Gibbs sampler storage parameters
mu <- list()
for (year in colnames(max.matrix)) {
  mu[[year]] = matrix(data=NA, nrow=n.iter, ncol=365)
  mu[[year]][1,] = rep(0, 365)
}
mu.iter = matrix(data=0, nrow=365, ncol=length(colnames(max.matrix)))
f = matrix(data=NA, nrow=n.iter, ncol=365)
f[1,] = rep(0, 365)
s2 = matrix(data=NA, nrow=n.iter, ncol=1)
s2[1,1] = s2.iter = 1
 
# Start Gibbs sampler
for (iter in 2:n.iter) {
  # Sample f
  f.iter = sample.f(max.matrix, mu.iter, s2.iter)
  f[iter,] = f.iter
  
  # Sample mu_i
  for (id in 1:length(colnames(max.matrix))) {
    mu.i = sample.mu.i(max.matrix[,id], f.iter, s2.iter)
    mu[[colnames(max.matrix)[id]]][iter,] = mu.i
    mu.iter[,id] = mu.i
  }
  
  # Sample s2
  s2.iter = sample.s2(max.matrix, f.iter, mu.iter)
  s2[iter,1] = s2.iter
  
  print(iter)
}

```

```{r}
f.avg = colMeans(f) 
f.df = data.frame(x=1:365, y=f.avg) 
ggplot(data=f.df, aes(x=x, y=y)) +
  geom_line() 
ggsave("./../Desktop/Sp22/modeling/SDS383c/project/fx_gibbs2_1000.jpeg")
```

```{r}
# Make plots of f(x) for each year 
for (year in colnames(max.matrix)) {
  f.avg = colMeans(f) + colMeans(mu[[year]])
  f.df = data.frame(x=1:365, y=f.avg)

  # Quantiles for ribbon
  short.quantiles = cbind(rep(0,365),rep(0,365))
  data.q = f + mu[[year]]
  for (i in 1:365) {
    short.quantiles[i,] = quantile(data.q[,i],c(0.05,0.95))
  }
  day = 1:365
  # Plot
  p=ggplot(data=f.df, aes(x=x, y=y)) + 
    ggtitle(paste0("Gibbs 2: Maximum O3 @ ACO in ", names_list[[year]]) ) + 
    xlab("Year") + ylab("O3 ppb") +
    geom_line() +
    #geom_point(data=data.frame(data_list[[year]]), aes(x=day, y=max), alpha=0.5, size=0.5) + 
    geom_ribbon(aes(ymin=short.quantiles[,1], ymax=short.quantiles[,2]), alpha=0.5) 
  
  ggsave(paste0("./../Desktop/Sp22/modeling/SDS383c/project/", year, "gibbs2", ".png"), 
         plot=p, 
         width = 40, 
         height = 20, 
         units = "cm"
         )
}
```

```{r}

# Now let's analyze mu for each year

# Average offset for each year (nueve through dieciseis)
nueve_offset = mean(colMeans(mu[["nueve"]])) # -1.345085
diez_offset = mean(colMeans(mu[["diez"]])) # 0.4717969
once_offset = mean(colMeans(mu[["once"]])) # 0.9155524
doce_offset = mean(colMeans(mu[["doce"]])) #  0.608444
trece_offset = mean(colMeans(mu[["trece"]])) # 1.227078
catorce_offset = mean(colMeans(mu[["catorce"]])) #0.2612708
quince_offset = mean(colMeans(mu[["quince"]])) # -1.188582
dieciseis_offset = mean(colMeans(mu[["dieciseis"]])) # -0.7562392

# Make a histogram of mu_i samples for each year
for (year in colnames(max.matrix)) {
  means = colMeans(mu[[year]])
  p = ggplot(data=data.frame(x=means)) + geom_histogram(aes(x=x))
  ggsave(
    paste0("./mu_plots/gibbs2/", year, "mu.png"),
    plot=p
  )
}


# and s2
plot(as.vector(s2), type="l")
mean(as.vector(s2)) # 8.792873
ggplot(data=data.frame(x=as.vector(s2)[-1])) + geom_histogram(aes(x=x, y=..density..))

save.image(file="gibbs2_10000_iter.RData")
```


```{r}
#########################################################################
#############   Gibbs Sampler with Metropolis Hastings  #################
#########################################################################

# This is a Gibbs sampler where we also update the parameters of the kernel 
# that we are using so we can capture the periodicity and added linearity

n.iter = 10000

# helper functions first
local_periodic <- function(xi, xj, sigma2=1, p=1, l2=4, c=1.5, a=1){
    sigma2 * exp(-2*sin(pi*abs(xi-xj)/p)^2/l2 ) * exp(-(xi-xj)^2/(2*l2)) * a*(xi-c)*(xj-c)
}

# get the whole matrix
periodic_covariance <- function(x, p=1, l2=4, c=1.5, sigma2=1, a=1) {
  temp = as.matrix(outer(x, x, function(xi, xj) local_periodic(xi, xj, sigma2, p, l2, c, a)))
  temp
}

sample.kernel <- function(params, C, C_inv, f) {
  # params are the parameters in the previous iteration: p, l_2, c
  # C_inv is the old C matrix inverted
  
  # proposal 
  proposal = rmvnorm(1, params, diag(3))
  C_new = periodic_covariance(1:365, p=proposal[1], c=proposal[3], l2=proposal[2])
  C_new_inv = solve(C_new)
  new_det_obj = determinant(C_new, logarithm=TRUE)
  old_det_obj = determinant(C, logarithm=TRUE)
  new_det = new_det_obj$sign[1] * new_det_obj$modulus[1]
  old_det = old_det_obj$sign[1] * old_det_obj$modulus[1]
  
  # acceptance probability 
  num = exp(-0.5 * f %*% C_new_inv %*% t(f))
  den = exp(-0.5 * f %*% C_inv %*% t(f))
  prob = min(1, 1/sqrt(exp(new_det - old_det)) * num / den)
   
  # return updated value
  if (runif(1) < prob) {
    return(list(C=C_new, C_inv=C_new_inv, par=proposal))
  } else {
    return(list(C=C, C_inv=C_inv, par=params))
  }
}

# Parameters: 
  # - Y is 365 by n_year matrix with pollution levels
  # - mu is 365 by n_year matrix with offset 
  # - s2 is sigma^2
# Returns: 
  # - One sample of conditional posterior draw of vector f(x)
sample.f <- function(Y, mu, s2) {
  # Normal conjugate 
  b = rep(0, 365)
  sigma = matrix(data=0, nrow=365, ncol=365)
  # for each year, calculate b_i and sigma_i then add them to b, sigma
  for (i in 1:dim(Y)[2]) {
    b.i = (Y[,i] - mu[, i]) / s2
    b = b + b.i
    sigma.i = Cinv + diag(1/s2, 365)
    sigma = sigma + sigma.i
  }
  post.var = solve(sigma)
  post.mean = post.var %*% b
  rmvnorm(1, post.mean, post.var)
}

# Parameters: 
  # y: 1x365 vector of values for one single year
  # f: previous draw of f(x) vector
  # s2: sigma^2
  # Cinv: currently inverse of covariance matrix
# Returns: 
  # 1x365 vector of offsets for single year
sample.mu.i <- function(y, f, s2, C_inv) {
  b = (y - f) / s2
  sigma = C_inv + diag(1/sigma.sq.mu, 365)
  post.var = solve(sigma)
  post.mean = post.var %*% matrix(b)
  rmvnorm(1, post.mean, post.var)
}

# This one stays the same as before it seems
# Parameters:
  # Y is 365 by n_year matrix with pollution levels
  # f - same as above
  # mu: 365 by n_year matrix with offset 
# Returns:
  # inverse gamma draw of s2
sample.s2 <- function(Y, f, mu) {
  a = 0.5 * 2416 - 1 # 2416 is total number of observations
  b = 0
  for (i in 1:dim(Y)[2]) {
    v = Y[,i] - f - mu[,i]
    b =b + 0.5 * t(v) %*% v
  }
  1/rgamma(1, a, b)
}


# Gibbs sampler storage parameters
mu <- list()
for (year in colnames(max.matrix)) {
  mu[[year]] = matrix(data=NA, nrow=n.iter, ncol=365)
  mu[[year]][1,] = rep(0, 365)
}
mu.iter = matrix(data=0, nrow=365, ncol=length(colnames(max.matrix)))
f = matrix(data=NA, nrow=n.iter, ncol=365)
f[1,] = rep(0, 365)
s2 = matrix(data=NA, nrow=n.iter, ncol=1)
s2[1,1] = s2.iter = 1
kernel_params = matrix(data=NA, nrow=n.iter, ncol=3)
# p, l_2, c
kernel_params[1,] = params.iter = c(1, 4, 1.5)
C.iter = periodic_covariance(1:365)
C_inv.iter = solve(C.iter)
 
# Start Gibbs sampler
for (iter in 2:n.iter) {
  # Sample f
  f.iter = sample.f(max.matrix, mu.iter, s2.iter)
  f[iter,] = f.iter
  
  # Sample mu_i
  for (id in 1:length(colnames(max.matrix))) {
    mu.i = sample.mu.i(max.matrix[,id], f.iter, s2.iter, C_inv.iter)
    mu[[colnames(max.matrix)[id]]][iter,] = mu.i
    mu.iter[,id] = mu.i
  }
  
  # Sample s2
  s2.iter = sample.s2(max.matrix, f.iter, mu.iter)
  s2[iter,1] = s2.iter
  
  # Metropolis Hastings on kernel params
  out = sample.kernel(params.iter, C.iter, C_inv.iter, f.iter)
  kernel_params[iter,] = out$par
  C.iter = out$C
  C_inv.iter = out$C_inv
  
  print(iter)
}


```


